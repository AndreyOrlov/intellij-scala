package org.jetbrains.plugins.scala.lang.lexer;

import com.intellij.lexer.FlexLexer;
import com.intellij.psi.tree.IElementType;
import java.util.*;
import java.lang.reflect.Field;
import org.jetbrains.annotations.NotNull;

%%

%class _ScalaLexer
%implements FlexLexer, ScalaTokenTypes
%unicode
%public

%function advance
%type IElementType

%eof{ return;
%eof}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// USER CODE //////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

%{
    private IElementType process(IElementType type){
        return type;
    }

%}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////  reserved words  ////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

KEYWORDS  =   "abstract" | "case"    | "catch"     | "class"      | "def"
            | "do"       | "else"     | "extends"   | "false"      | "final"
            | "finally"  | "for"     | "if"        | "implicit"   | "import"
            | "match"    | "new"     | "null"      | "object"     | "override"
            | "package"  | "private" | "protected" | "requires"   | "return"
            | "sealed"   | "super"   | "this"      | "throw"      | "trait"
            | "try"      | "true"    | "type"      | "val"        | "var"
            | " while"    | "with"    | "yield"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////      integers      ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

integerLiteral = (decimalNumeral | hexNumeral | octalNumeral) ['L' | 'l']
decimalNumeral = '0' | nonZeroDigit {digit}
hexNumeral = '0' 'x' hexDigit {hexDigit}
octalNumeral = '0' octalDigit {octalDigit}
digit = '0' | nonZeroDigit
nonZeroDigit = '1' | . . . | '9'
octalDigit = '0' | . . . | '7'

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////      identifiers      ///////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

upper = 'A' | . . . | 'Z' |  '_' //and Unicode Lu //'\$' |
lower = 'a' | . . . | 'z' //and Unicode Ll

letter = upper | lower //and Unicode categories Lo, Lt, Nl
digit = '0' | . . . | '9'
special = '\u0020' | ... | '\u007F' 
//special = “all other characters in\u0020-007F and Unicode categories

//Sm, So except parentheses ([]) and periods”
op = special {special}

idrest = (letter | digit)*  ['_' op]
varid = lower idrest
plainid = upper idrest
    | varid
    | op

id = plainid
| '\'' stringLiteral '\''



characterLiteral = '\'' char '\'' | '\'' charEscapeSeq '\''

stringLiteral = '\"' {stringElement} '\"'
stringElement = charNoDoubleQuote | charEscapeSeq

charEscapeSeq = "\\" | "\\t" | "\\n" | "\\r" | "\\f" | "\\b" | "\\'"  //| "\\""

EOL= "\r" | "\n"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// Operations //////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
OP =    "|" | "^"' | "&" | "<=>" | "==" | "===" | "=~" | ">" | ">=" | "<" | "<=" | "<<" | ">>"
        | "+" | "-" | "*" | "/" | "%" | "**" | "~" | "+@" | "-@" | "[]" | "[]=" | "`"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////  floating point  //////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

floatingPointLiteral = digit {digit} '.' {digit} [exponentPart] [floatType]
                        | '.' digit {digit} [exponentPart] [floatType]

                        | digit {digit} exponentPart [floatType]
                        | digit {digit} [exponentPart] floatType
exponentPart = ('E' | 'e') ['+' | ''] digit {digit}
floatType = 'F' | 'f' | 'D' | 'd'


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////  boolean values ///////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
booleanLiteral = true | false


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////  unicode escape  //////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UNICODEESCAPE = \{\\}u{u} HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////  white spaces /////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
WHITESPACESCHAR = \u0020 | \u0009 | \u000D | \u000A
WHITESPACES = {WHITESPACESCHAR}+


%%
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////// rules declarations ////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<YYINITIAL>{
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// comparison operators ///////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


"+"                                     {   return tPLUS; }
"-"                                     {   return tMINUS; }
"*"                                     {   return tSTAR; }
"/"                                     {   return tDIV; }

"=="                                    {   return tEQUAL; }
"!="                                    {   return tNOTEQUAL; }
"<"                                     {   return tLESS; }
"<="                                    {   return tLESSOREQUAL; }
">"                                     {   return tGREATER; }
">="                                    {   return tGREATEROREQUAL; }


{WHITESPACES}                           {   return tWHITE_SPACE; }
{EOL}                                   {}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// braces //////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"["                                     {   return tLBRACKET; }
"]"                                     {   return tRBRACKET; }

"{"                                     {   return tLBRACE; }
"}"                                     {   return tRBRACE; }

"("                                     {   return tLPARENTHIS; }
")"                                     {   return tRPARENTHIS; }


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////// keywords /////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

"abstract"                              {   return process(kABSTRACT); }
"case"                                   {   return process(kCASE); }
"catch"                                 {   return process(kCATCH); }
"class"                                 {   return process(kCLASS); }

"def"                                   {   return process(kDEF); }
"do"                                 {   return process(kDO); }
"else"                                 {   return process(kELSE); }
"extends"                                  {   return process(kEXTENDS); }
"false"                                 {   return process(kFALSE); }
"final"                                 {   return process(kFINAL); }
"finally"                                 {   return process(kFINALLY); }
"for"                                   {   return process(kFOR); }
"if"                                   {   return process(kIF); }
"implicit"                                   {   return process(kIMPLICIT); }
"import"                                   {   return process(kIMPORT); }
"match"                                   {   return process(kMATCH); }
"new"                                   {   return process(kNEW); }
"null"                                   {   return process(kNULL); }
"object"                                   {   return process(kOBJECT); }
"override"                                   {   return process(kOVERRIDE); }
"package"                                   {   return process(kPACKAGE); }
"private"                                   {   return process(kPRIVATE); }
"protected"                                   {   return process(kPROTECTED); }
"requires"                                   {   return process(kREQUIRES); }
"return"                                {   return process(kRETURN); }
"sealed"                                {   return process(kSEALED); }
"super"                                {   return process(kSUPER); }
"this"                                {   return process(kTHIS); }
"this"                                {   return process(kTHIS); }
"throw"                                {   return process(kTHROW); }
"trait"                                {   return process(kTRAIT); }
"try"                                {   return process(kTRY); }
"true"                                  {   return process(kTRUE); }
"type"                                  {   return process(kTYPE); }
"val"                                  {   return process(kVAL); }
"var"                                  {   return process(kVAR); }
"while"                                  {   return process(kWHILE); }
"whith"                                  {   return process(kWHITH); }
"yield"                                 {   return process(kYIELD); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// Variables  /////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

{id}                            {   return tID; }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////// Literals /////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

{integerLiteral}                       {   return tINTEGERLITERAL; }

}